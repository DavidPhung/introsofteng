%
% Copyright 2017 Markus Borg, Lund University
%
% This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
% See http://creativecommons.org/licenses/by-sa/4.0/
%
% The dodument is based on a LaTeX template developed by Jean-Philippe Eisenbarth
% https://github.com/jpeisenbarth/SRS-Tex
%
\documentclass{scrreprt}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Software Requirement Specification},    % title
    pdfauthor={Markus Borg},                     % author
    pdfsubject={TeX and LaTeX},                        % subject of the document
    pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=purple,        % color of external links
    linktoc=page            % only page is linked
}%
\def\myversion{0.2 }
\date{}
%\title{%

%}
\usepackage{hyperref}
\begin{document}

\begin{flushright}
    \rule{16cm}{5pt}\vskip1cm
    \begin{bfseries}
    	\LARGE{ETSA02-ADM-INS}\\
    	\vspace{1.5cm}
        \Huge{Project\\ Instructions}\\
        \vspace{0.5cm}
        for\\
        \vspace{0.5cm}
        the LU Rumble\\
        \vspace{1.5cm}
        \LARGE{Version \myversion}\\ %approved}\\
        \vspace{1.5cm}
        Prepared by Markus Borg\\
        %\vspace{1.5cm}
        Dept. of Computer Science, Lund University\\
        \vspace{1.5cm}
        \today\\
    \end{bfseries}
\end{flushright}

\tableofcontents


\chapter*{Revision History}

\begin{center}
    \begin{tabular}{|c|c|p{8cm}|c|}
        \hline
	    Name & Date & Change description & Version\\
        \hline
	    Markus Borg & 2017-12-07 & Initial draft. & 0.1\\
        \hline
        Markus Borg & 2017-12-27 & Complete draft of intro, engineering, monetizing, and strategizing. Sent for external review. & 0.2\\
        \hline
        Markus Borg & 2017-12-XX & First draft of sprints. & 0.3\\
        \hline
    \end{tabular}
\end{center}

\chapter{Introduction}
This document describes the project in ETSA02 Introduction to Software Engineering -- Methodology. Together with other students, you will work together to engineer a robot for competition in LU Rumble -- a local instance of team battles in Robocode. 

In the remainder of this document, we use the term ``group'' to refer to the students working together during the project. While the student constellations would better be described as teams, i.e., groups of people working together toward a common goal, we reserve the term ``team'' to robots competing together in Robocode.

This document is organized as follows: TODO.

\section{Learning goals}
The project primarily aims to increase your ability to develop high quality software systems using established software engineering best practices. Moreover, basic software business concepts will be introduced  as each group will offer their product on a highly competitive market.

The project complements the theoretical concepts introduced during the lectures by taking a practical approach to the presentation of fundamental software engineering concepts such as specification, version control, testing, sprints, and releases. By the end of the course, you will have acquire new skills with essential components of the contemporary  software engineering tool chain: the Java programming language, the Eclipse integrated development environment, the JUnit testing framework, the git configuration management system, GitHub cloud-based project hosting, the Maven build system, and the Checkstyle, PMD, and FindBugs automated quality assurance tools.

On top of your skills with traditional software engineering concepts and the tool chain, you will address aspects of both bespoke and market-driven software engineering. Each group will practice making critical business and engineering decisions in a controlled fashion -- using the course as an open market. The course introduces several important activities in software business, including analyzing the software ecosystem, finding a niche market, marketing a product, competitive pricing strategies, and customer negotiations.

TODO: Make sure this is aligned with the formal course description.

\section{Robocode -- Build the best, destroy the rest!}
The goal of Robocode is to implement the behavior of a robot to compete against other robots in a battle arena. The contestants have no direct influence on the game, instead they write the AI of the robot telling it how to behave and react on events occurring in the battle arena. Battles are running in real-time and on-screen, see Figure~\ref{fig:screenshot}. Robocode battles, referred to as ``rumbles'', are either in the form of duels between individual robots, free-for-all battles with multiple robots, or battles between robot teams.

\begin{figure}
\centering
\includegraphics[width=0.80\textwidth]{figures/screenshot.png}
\caption{Screenshot from the Robocode battle arena. (Image credit: robowiki.net user MultiplyByZer0)}
\label{fig:screenshot}
\end{figure}

\textit{From http://robocode.sourceforge.net/docs/ReadMe.html}:
Robocode offers complete development environment, and comes with its own installer, built-in robot editor and Java compiler. Robocode only pre-requires that a JVM (Java Virtual Machine) to exist already on the system where Robocode is going to be installed. Hence, everything a robot developer needs to get started is provided with the main Robocode distribution file (robocode-xxx-setup.jar). Robocode also supports developing robots using external IDEs like Eclipse.

Robocode is an Open Source project, which means that all sources are open to everybody. In addition, Robocode is provided under the terms of EPL (Eclipse Public License). The Robocode game was originally started by Mathew A. Nelson as a personal endeavor in late 2000 and became a professional one when he brought it to IBM in July 2001. In the beginning of 2005, Mathew convinced IBM to release Robocode as Open Source on SourceForge. Eventually, Flemming N. Larsen took over the Robocode project at SourceForge as administrator and developer in July 2006 to continue the original Robocode game -- which now is hosted on GitHub.

\section{Project overview}
Each project team will develop a robot using established software engineering practices. Furthermore, each team will compose a robot team to compete in a ``LU Rumble'' at the final lecture in the course. However, no team is allowed to field their own robot -- instead robots developed by other teams must be purchased on an open market (in truth a somewhat regulated market). Consequently, each team has two primary goals: 1) maximizing profit by selling a successfully engineered robot on the market and 2) winning the LU Rumble by composing a competitive Robocode team. Teams pursue the two goals by completing three main activities that we refer to as \textit{strategizing}, \textit{engineering}, and \textit{monetizing}, respectively.

Figure~\ref{fig:overview} shows the four main phases of the project. First, during the course inception, the course infrastructure and the project tasks are introduce. More importantly, teams consisting of six students (preferably!) are established. Second, the backbone of the course follows: three development sprints mixing engineering, monetizing, and strategizing. Third, purchasers of robots perform acceptance testing to ensure that the delivered robot fulfills the expectations -- otherwise purchasers file business claims to require money back. Fourth, in the last phase of the project, the LU Rumble takes place followed by an awards ceremony to recognize the both winners -- and the most profitable teams.

\begin{figure}
\centering
\includegraphics[width=0.99\textwidth]{figures/projectOverview.png}
\caption{Project overview.}
\label{fig:overview}
\end{figure}

Figure~\ref{fig:context} shows the context of each individual group during the project. Organizationally, your group has three divisions: 1) engineering, 2) purchasing, and 3) sales. Your group will assign the following roles: 1) project manager, 2) requirements engineer, 3) development lead, 4) test lead, 5) domain expert, and 6) sales engineer. Each role is described in detail in Section~\ref{sec:org}.

Groups do not exist in isolation, instead they act in a software ecosystem [REF]. During engineering of the robot, each group will be part of two supplier-customer relationships. First, your sales engineer will be responsible for marketing the robot under development. The domain expert of another team will sign a contract of sale, establishing a formal relationship. Your sales engineer will be the primary communication point for the purchasing group's domain expert, i.e., a supplier-customer relationship involving feedback, feature requests, and negotiations. Second, analogously, your domain expert will act as the customer in a supplier-customer relationship with another group. Note that, in some cases, groups might buy from and sell to the same other group -- this is not regulated in the ecosystem.

On top of the two supplier-customer relationships, your group will also communicate with the regulatory body (represented by your project supervisor). Your group will hand in various signed contracts to the regulatory body, turn to it if to get support during supplier-customer negotiations, and to report the results from your acceptance testing. The regulatory body might also contact you with regulatory changes during the course of the project. Finally, you will practice one-way communication with the Robot Market, i.e., the open market where you will sell your Robot. All groups will complement their teams with additional robots during the last week of the project -- and your sales engineer will be responsible for maximizing sales of your robot. 

\begin{figure}
\centering
\includegraphics[width=0.99\textwidth]{figures/projectContext.png}
\caption{Project context.}
\label{fig:context}
\end{figure}

\section{Project grading}
The project will be graded as 3, 4, 5 or UG. TODO: Group grading and individual grades.

The project supervisors' overall grading guidelines include the following:
\begin{itemize}
\item The final release meets the final requirements specification. This is partly indicated by the customer's successful acceptance testing.
\item The delivered robot is successful and non-trivial.
\item All the robots behaviors are covered by the requirements specification.
\item The test specification describes a comprehensive verification of the robot. Automated test cases and test reports are provided.
\item The team adhered to the process model and met all deadlines.
\item All deliverables are of high quality. Appropriate technical language and a consistent look-and-feel across documents.
\end{itemize}

\chapter{Engineering the robot}
Each team will develop a robot (see Figure~\ref{fig:robot}) according to established engineering principles. These principles include product prototyping, integrated requirements engineering, and automated testing. The process model is organized in three development sprints, further described in Section~\ref{sec:process}. The engineering process is dominated by three core activities: \textit{specification}, \textit{construction}, and \textit{verification}. In line with agile development methodologies, all sprints consist of a mix of these three activities. Still, the groups' focus during the project will progress from specification, through construction, to verification -- also reflected by the order of the lectures.

\begin{figure}
\centering
\includegraphics[width=0.50\textwidth]{figures/robotSide.jpg}
\caption{Model of the Robocode robot (\copyright~Klaus Knopper under CC BY-SA 3.0).}
\label{fig:robot}
\end{figure}

\section{Specification}
Requirements engineering, i.e., a systematic approach to developing a product with an end-user perspective, will be an integrated activity throughout the project. The requirements will be captured in a Software Requirements Specification (SRS) adhering to a template structure provided by the Institute of Electrical and Electronics Engineers (IEEE). IEEE is the world's largest technical professional organization, and a natural resource for software engineers -- possibly contented by the Association of Computing Machinery (ACM). Both organizations support engineers in development of software products adhering to state-of-practice approaches and provide ethical guidelines.

The IEEE SRS template provides a standard document structure: 1) an introduction section, 2) an overall description of the product under development, and 3) a list of product features further broken down into detailed requirements. Furthermore, the template supports engineers to specify quality requirements such as performance, maintainability, and memory footprint. Groups are recommended to use a combination of traditional requirements of ``shall'' format and step-wise use case descriptions. While also user stories are covered in the lectures, it uses a narrative style that is less appropriate for development of autonomous robots.

The SRS connects all roles in the student group. While the requirements engineer is responsible for the SRS, the sales engineer is responsible for developing a marketing strategy based on its content. The SRS will be public on the Robot Market, i.e., when other teams consider purchasing your robot, they will critically review your SRS. The domain expert, having the most chance to predict what features will be valued on the Robot Market, will provide important input to the SRS -- effectively acting as a proxy-customer until the supplier-customer relationship has been established. Finally, the development lead is responsible for implementing the SRS in source code and the test lead is responsible for verifying that the developed product fulfills the SRS.

There are several quality attributes that a high-quality SRS should comply with. First, the SRS should be complete, i.e., if properly implemented, the developed product shall be a competitive robot. Just as importantly, the robot shall not offer any features that are not properly captured in the SRS -- the customer is not allowed any surprises. Second, the SRS should constitute a coherent document that is easy to follow. Furthermore, each individual requirement should be:

\begin{description}
\item[Complete] All information needed to implement source code to fulfill the requirement shall be specified. Developers must not be forced to read between the lines.
\item[Consistent] There are no contradictions between individual requirements.
\item[Feasible] The requirement can be practically implemented by the developers given the available resources. Also, the requirement will bring value to the end user or another stakeholder.
\item[Modifiable] An SRS is rarely static, thus all requirements must be able to change. Each requirement should be clearly identifiable.
\item[Unambiguous] A requirement shall only be interpretable in one way, i.e., no subjectivity can exist. Quality requirements should be quantified, not described using vague adjectives.
\item[Design free] Requirements shall specify what the system must or must not do, but not how the software will ensure the requirement is met -- leave that to the construction phase.
\item[Testable] Requirements shall be possible to verifiable, preferably by testing, otherwise inspection. 
\end{description}

As a result from the specification activities, each group shall produce the following deliverables, further described in Section~\ref{sec:process}:
\begin{description}
\item[Sprint 1] SRS v0.5 -- Main features captured
\item[Sprint 2] SRS v0.9 -- Detailed requirements specified
\item[Sprint 3] SRS v1.0 -- A complete Robot specification
\end{description}

\section{Construction}
The first two computer labs will help groups set up Robocode development in Eclipse and source code control in git. Moreover, the second computer lab will initiate automated unit testing, an activity that overlaps construction and verification.

An early construction activity is software design. In this project, the design is limited to object-oriented design -- the robot development is too restricted to address any considerations on the software architecture level and there is also no user interaction design. Each group will present the Object-Oriented Design (OOD) using a Unified Modeling Language (UML) class diagram. As the project in inspired by agile development methodologies, there will be no big design activity upfront. Instead, the OOD will evolve as the construction phase proceeds. The development lead is responsible to complement the final source code delivery with a class diagram to describe the OOD after-the-fact. Any group that recognizes a value in using class diagrams in their  robot marketing are of course welcome to do so. Furthermore, the final source code deliverable shall be complemented by Javadoc documentation.  

As most practical construction work will be done outside of scheduled sessions, how the backbone of the programming will be conducted must be decided by the individual groups. Still, for this project, we recommend groups to follow a handful of well-known agile development practices, originally proposed as part of Extreme Programming (XP) [REF]. Below we list five that we believe are particularly suitable for the process model, along with their Wikipedia definitions:

\begin{description}
\item[Pair programming] All code is produced by two people programming  on one workstation. One programmer has control over the workstation and is thinking mostly about the coding in detail. The other programmer is more focused on the big picture, and is continually reviewing the code that is being produced by the first programmer. Programmers trade roles after minute to hour periods. The pairs are not fixed; programmers switch partners frequently, so that everyone knows what everyone is doing, and everybody remains familiar with the whole system, even the parts outside their skill set. This way, pair programming also can enhance team-wide communication and goes hand-in-hand with the concept of Collective Code Ownership.
\item[Continuous integration] The development team should always be working on the latest version of the software. Since different team members may have versions saved locally with various changes and improvements, they should try to upload their current version to the code repository every few hours, or when a significant break presents itself. Continuous integration will avoid delays later on in the project cycle, caused by integration problems, aka. ``big bang integration''.
\item[Code refactoring] Restructuring existing code without changing its external behavior. Refactoring improves quality attributes of the software, e.g., code readability, performance, maintainability. Refactoring is often initiated when a so called ``code smell'' is identified, i.e., structures in the code that indicate violation of fundamental design principles and negatively impact design quality. 
\item[Test-driven development] Create unit tests before the eventual code is written. This approach is intended to stimulate the programmer to think about conditions in which his or her code could fail. Test driven development proceeds by quickly cycling through the following steps: 1) write unit tests, 2) run tests, watch them fail, 3) write code, 4) run tests, watch them pass, and 5) refactor the code. Adhering to test-driven development leads to a large set of test cases that can be automatically executed, increasing developers' confidence when e.g. refactoring code.
\item[Collective code ownership] Everyone is responsible for all the code; therefore, everybody is allowed to change any part of the code. Collective code ownership is not only an organizational policy but also an attitude. Pair programming, especially overlapping pair rotation, contributes to this practice: by working in different pairs, programmers better understand the system context and contribute to more areas of the code base. Collective code ownership may accelerate development because a developer who spots an error can fix it immediately, which can reduce bugs overall. However, programmers may also introduce bugs when changing code that they do not understand well. Sufficiently well-defined unit tests should mitigate this problem: if unforeseen dependencies create errors, then when unit tests are run, they will show failures.
\end{description}

The construction phase involves prototyping to quickly create a working robot. Prototyping supports specification activities by enabling early executable software -- truly beneficial in contexts where the requirements are very unstable. Already at the end of sprint 1, around the LU Robot Fair, the group shall deliver a first version of the robot. In line with lean software development practices, the first version shall be a Minimum Viable Product (MVP), i.e., a product with just enough features to satisfy early customers to enable feedback for future product evolution throughout sprints 2 and 3. 

As a result from the construction activities, each group shall produce the following deliverables. Each release shall be prepared as two jar-files: 1) one jar-file for customers and 2) one jar-file with embedded source code for the regulatory body. As previously stated, the final release to the regulatory body shall be complemented by a class diagram and Javadoc documentation, as further described in Section~\ref{sec:process}:
\begin{description}
\item[Sprint 1] Robot Alpha release (Robot v0.5) -- An MVP
\item[Sprint 2] Robot Beta release (Robot v0.9) -- A better robot
\item[Sprint 3] Robot Final release (Robot v1.0) -- The final robot
\end{description}

\section{Verification}
The first two computer exercises will introduce working with the JUnit framework for automated testing. Groups will work with unit testing as a natural companion to the programming during development. While JUnit is designed for automated execution of unit test cases, groups will also use JUnit for system testing of both functional and non-functional (quality) aspects of the robot under development. Finally, groups will learn to use measure code coverage and use static code analysis tools to support software quality assurance.

The test lead is responsible for delivering three growing development artifacts during the projects, as well as a final test report at the final release. First, a suite of automated unit test cases shall evolve during during the project. At sprint 1, an initial version shall simply be executable, but at the final release all source code shall be exercised by unit tests. Second, a suite of automated system test cases shall be developed -- an initial version at sprint 2, and the complete suite with the final release. Third, a test specification that describes the group's test and quality activities. At sprint 3, all requirements in the SRS shall be verified either by automated test cases or targeted by a convincing argumentation that the requirement has been verified through inspection.

Verification activities are naturally supported by tools. Apart from the JUnit framework, the groups will use Eclipse plugins to measure code coverage and a set of static analysis tools to automatically analyze the source code from different quality perspectives. TODO: describe the tools to use.

The final robot release shall be accompanied with a test report, signed by the test lead, showing that all test cases have been executed -- and all corresponding test verdicts. The customer will surely expect that all test cases passed, i.e., that you provide evidence that the entire SRS has been fulfilled by the final robot. In addition to the test verdicts, the test report shall contain appendices with extracted report from the code coverage tool as well as the static code analysis tools.

As a result from the verification activities, each group shall produce the following deliverables, further described in Section~\ref{sec:process}:
\begin{description}
\item[Sprint 1] Test specification v0.5 -- Initial unit test suite
\item[Sprint 2] Test specification v0.9 -- Initial system test suite
\item[Sprint 3] Test specification v1.0 and a signed test report
\end{description}

\chapter{Monetizing the robot}
One of the primary goals of the project is to maximize the profit of the group, i.e., monetizing the robot. The business aspects of the project involves a combination of bespoke software engineering and software engineering for an open market. All groups will offer their robot on a highly competitive market -- consisting of the other groups, each with a \$100 budget to invest in a robot team for the LU Rumble.

The groups will market their Robot already at a robot fair already after Sprint 1. At this early point in time, only an Alpha release of the robot will be available and an initial version of the SRS -- still, the sales engineer is responsible for developing a convincing marketing concept. All groups will get the chance to pitch their robot at the robot fair, and also present it online on the Robot Market, complemented by the most recent SRS.

After the robot fair, all groups will submit a ``purchase array'' to the regulatory body. The purchase array consists of one element per group, and each element should contain an integer representing how much your group is willing to pay for the corresponding robot (TODO: add a figure). You are not allowed to make an offer for your own robot, and you are not allowed to offer less than \$10 for any other robot. The purchase array should be signed by the domain expert and delivered as a physical copy to the regulatory body through the mailbox in ``grå skåpet''.

When all groups have provided their purchase arrays, the regulatory body will commence its work to establish supplier-customer relationships. For each robot, the highest bidder turns into a customer of the group engineering the corresponding robot. If there is a tie, the customer relationship will be assigned randomly. In the end, all groups will 1) pre-order a robot from a supplier, and 2) have a customer that offered at least \$10 to pre-order a robot (the price of the cheapest basic bot, see TODO). Note that the decision of the regulatory body cannot be appealed. 

Once robots have been pre-ordered, 25\% of their costs will be transferred from the customer to the supplier. This amount will not be refunded in any case -- it represents the risks of purchasing a robot from an external organization. The remainder of the cost will be transferred at the delivery of the final robot. After the final delivery, the domain expert of the purchasing group conducts acceptance testing of the robot. If the acceptance testing shows that delivered robot does not fully comply with the SRS, the project manager of the purchasing group is entitled to file a business claim to the regulatory body, further described in Section~\ref{sec:regbody}.

Each group will also offer the robot under development on the Robot Market. After Sprint 3, all groups will seek to complement the pre-ordered (by now hopefully delivered) robot with additional robots to build a competitive robot team for the LU Rumble. Throughout Sprints 2 and 3, the sales engineer is responsible for marketing the robot on Robot Market. Each group will also set a price for its robot -- a group must for at least ask as much as what the bespoke customer has payed. Before the LU Rumble, the domain expert of each team will sign purchase orders and deliver to the regulatory body through ``grå skåpet''. 

Figure~\ref{fig:market} shows an example of how two groups purchase robots. After the robot fair, Group A purchases a bespoke robot from Group C. As Robot C was quite costly, Group A complements it with two cheaper droids from Robot B to create a robot team. On the other hand, Robot B resulted from bespoke development for Group C -- and they liked the result enough to buy two more at a later stage. Furthermore, Group C complements the cheap droids by two basic bots: a Basic Leader Bot and a Basic Bot. Both Groups A and C spend \$95 of their budgets.

\begin{figure}
\centering
\includegraphics[width=0.85\textwidth]{figures/marketExample.png}
\caption{Example of two groups purchasing robots for their teams.}
\label{fig:market}
\end{figure}

\chapter{Strategizing to win the LU Rumble}
The LU Rumble is a customized instance of a RoboCode team rumble. Each group will compose a team of up to five robots that will compete together against other teams. Each team must have one leader robot, which can be complemented by normal robots or droids.

As in any rumble, the goal is to reduce the energy of enemy robots to 0. Team robots will compete on a battlefield until one team is left. A standard robot starts with 100 energy and is equipped with a radar and a gun turret. Each time the gun is fired, the robot loses energy according to the payload. If the bullet does not hit any target, the energy is lost. If the bullet hits another robot, energy is transferred from the hit robot to the firing robot.

Apart from the standard robots, there are two special types of robots. The leader robot has an additional 100 energy compared the normal robot. Droids have an additional 20 energy, but are not equipped with radars.

At the end of Sprint 1, your group will have established a relationship with a robot supplier by pre-ordering either a leader robot, a normal robot, or a droid. The supplier will provide you with a final robot at the end of Sprint 3, but your group will have a chance to influence the evolution of the robot during Sprints 2 and 3. The domain expert in your group is responsible for developing a strategy around the robot you have pre-ordered -- to guide your feedback, you will receive two prototypes for evaluation: an Alpha release after Sprint 1, and a Beta release after Sprint 2.

At the end of Sprint 3, you will complement the robot you have ordered with other robots from the Robot Market. The goal of your strategizing is to identify and purchase additional robots that can successfully cooperate with the robot from your supplier. It is important to keep an eye on the Robot Market during Sprints 2 and 3, both to find the best robots to purchase, and to understand what type of features you should provide through your own robot under development. Note that three robots are always available at fixed prices: 1) BasicLeaderBot \$20, 2) BasicBot \$15, and 3) BasicDroid \$10.

Each team must adhere to three strict constraints: 

\begin{enumerate}
\item Each team must consist of between one and five robots, including one leader robot.
\item Each team has a budget of \$100 to purchase robots.
\item The final team must be submitted as a jar-file to the LU Rumble on Friday morning before the event. 
\end{enumerate}

\chapter{The regulatory body} \label{sec:regbody}
Formal document templates:

\begin{itemize}
\item Contract of sale between supplier and customer
\item Purchase order for Robot Market
\item Business claims
\end{itemize}

\chapter{Maintaining supplier-customer relations}
What to do and what not to...\\

Guidelines for suppliers:
\begin{itemize}
\item The customer is always right
\item Do not sacrifice the chance to succeed on the open market
\item Be open to new ideas from the customer.
\item Embrace change -- it is inevitable anyway.
\item Negotiate nicely.
\end{itemize}

Guidelines for customers:
\begin{itemize}
\item Accept what you've pre-booked.
\item Do not provide feedback that deviates from the original vision of the robot.
\item Be open to alternative solutions proposed by the supplier.
\item Negotiate nicely.
\end{itemize}

\chapter{Process model} \label{sec:process}
The process model describing the product development encompasses three sprints, each with a separate set of deliverables. 
After the three sprints, the final part of the course is dedicated to acceptance testing (potentially followed by filing of formal business complaints) and, of course, the concluding LU Rumble and the award ceremonies. 

\begin{figure}
\centering
\includegraphics[width=0.85\textwidth]{figures/processModel.png}
\caption{Process model.}
\label{fig:overview}
\end{figure}

%Produktutvecklingen genomförs i fyra faser enligt modellen Unified Software Development
%Process [Jacobson et al., 1999]: 1) Inception, 2) Elaboration, 3) Construction och 4) Transition.
%De mest omfattande faserna är uppdelade i flera iterationer. Faserna visas överst i figur 3.1 och
%iterationerna presenteras nederst.
%
%Varje fas kommer att domineras av en typ av arbete, men även kompletterande arbete av tidigare
%slag, dvs. arbetstyperna överlappar. Exempelvis kommer viss kravhantering att fortsätta ske
%även under fasen Construction – krav kommer troligtvis att behöva kompletteras eller förfinas.
%Varje fas är uppdelad i interationer genom ett antal vecko-sprints. Kombinationen av fasernas
%överlappande arbetsuppgifter samt uppdelning i sprints möjliggör iterativt arbete, vilket ofta är
%en nyckel för framgångsrika utvecklingsprojekt.
%
%Fas 2 och 3 avslutas med milstolpar. Avsikten med en milstolpe är att det tydligt ska framgå
%om den uppnåtts eller inte och på så vis synliggöra hur långt projektet kommit. Exakt vad som
%ingår i de olika milstolparna bör vara känt av samtliga deltagare i projektet och övriga andra
%intressenter, såsom kunder och linjechefer. Projektet har två milstolpar som uppnås när samtliga
%inblandade leverabler är godkända av alla berörda parter. När en milstolpe har passerats
%betraktas huvuddelen av fasens arbete slutfört, därefter sker enbart komplettering och förfining.
%Den grundläggande tanken med projektmodellen är att en fas inte påbörjas förrän föregående 
%milstolpe har uppnåtts. Men även om man inte startar en fas innan de tidigare faserna är
%slutförda är det naturligtvis tillåtet, och i många fall lämpligt, att börja förbereda sig för framtida
%faser. Till exempel, om du vet att du kommer att implementera ett användargränssnitt i
%implementationsfasen men du vet inte hur man gör detta, då du kan börja förbereda implementationsfasen
%tidigt i projektet. Du kan börja studera användargränssnitt, fråga folk som vet mer
%om ämnet eller skapa en mindre prototyp för användargränssnitt bara för att lära sig hur man
%gör. Man kan naturligtvis, i mån av tid, även chansa och påbörja något som man räknar med
%eller hoppas kan bli användbart senare i projektet, men du bör då vara medveten om risken att
%kraven och design kan ändras tidigt i projektet och att det inte är säkert att programkoden du
%har skrivit verkligen blir användbar.

\section{Sprint 1}
Team formation, feature scoping, prototyping, marketing concept

%Projektets första fas innebär en uppstart av projektet. Projektmedlemmarna får en chans att
%träffas och eventuellt nya kontakter etableras. För att gruppen ska fungera bra ihop under projektets
%gång är det viktigt att medlemmarna kommunicerar effektivt med varandra – försök
%komma överens om hur ni kan säkerställa detta. Det är även bra att diskutera era målsättningar,
%eftersom olika förväntningar på arbetsinsats och projektbetyg är en av de främsta orsakerna till
%konflikter i grupparbeten. Relaterat till detta kommer ni även utse olika roller i projektet, dvs.
%ansvarsområden. Detta ska ni beskriva i projektplanen, där ni även i grova drag ska planera
%ert arbete. Slutligen kommer ni att lära känna den dokumentstruktur som ska följas på Google
%Drive.
%Fas 1 avslutas inte med en formell milstolpe, men trots det produceras viktiga resultat:
%Gruppens målsättning förankras
%Infrastruktur skapas på Google Drive
%Projektplan

\section{Sprint 2}
Maintain business relations, evolve product, develop Rumble strategy

%Projektets andra fas innebär en detaljerad analys av kundens behov och en efterföljande teknisk
%kravställning. Arbetet i denna fas utgår från en idé om vad man ska genomföra samt från en
%rad förutsättningar vad gäller tidsplaner, tidsfrister och budget i förhållande till kostnaden. Den
%inledande projektidén är beskriven på en hög nivå som inte är tillräckligt tydlig för att i detalj
%definiera exakt vad som ska utvecklas. Arbetet i denna fas syftar till att precisera exakt vad
%som ska utvecklas under resten av projektet. I denna fas utvecklas även en högnivådesign för
%produkten, dvs. ett klassdiagram.
%Fas 2 avslutas med Milstolpe 1 (MS1). Milstolpen godkänns av projekthandledaren och nås
%när både Projektplan (från Fas 1) och Kravspecifikation är godkända.

\section{Sprint 3}
Complete product, maximize sales, optimize Rumble strategy

%I den tredje fasen av projektet ligger fokus på att utveckla det exekverbara programmet. Detta
%innebär att varje utvecklare utvecklar programkod som kompileras och enhetstestas. Enhetstest
%innebär att man testar delar av programmet isolerat från övriga delar av systemet. Källkoden
%ska även dokumenteras, vilket i kombination med högnivådesignen utgör ett designdokument.
%Utöver detta färdigställs testplan och de testfall som ska genomföras i den sista fasen.
%Fas 3 avslutas med Milstolpe 2 (MS2). Vid denna milstolpe ska Testplan godkännas. Detta
%görs inom projektgruppen efter en intern granskning (se avsnitt 3.6) av dokumentet. När
%testplanen godkänts inom gruppen sätts de i baseline, dvs. version 1.0 varpå de tillsammans
%med granskningsprotokoll skickas för kännedom till projekthandledaren. Om projekthandledaren
%har ytterligare synpunkter kan det bli aktuellt att göra ytterligare förändringar av något eller
%båda dokumenten. För de ändringarna, och eventuell andra framtida ändringar gäller formell
%ändringshantering enligt avsnitt 3.6 med den skillnaden att projekthandledaren inte behöver
%engageras.

\section{Acceptance testing and business claims}
%I den fjärde och sista fasen av projektet ligger fokus på att testa hela systemet och överlämna
%det till kund. Det innebär att alla enheter av programvaran måste integreras till ett system
%Faser och milstolpar 23
%som kan testas. Vid systemtest verifieras att systemet uppfyller alla krav i kravspecifikationen.
%Detta görs genom att man kör samtliga testfall i testplanen. Systemtesterna dokumenteras i en
%Testrapport som för varje testfall visar om det lyckas eller inte. Fasen kan inte avslutas förrän
%alla testfall genomförs utan misslyckanden. Detta innebär att om något test avslöjar fel får man
%gå tillbaka och ändra i de utvecklade produkterna (krav, kod, etc.) och upprepa samtliga testfall.
%Projektgruppen ska även skriva en kort Användarmanual för systemstart.

\section{LU Rumble and Awards}
%Efter fas 4 har den utvecklade produkten levererats till kund och projektet kan därmed avslutas.
%Sedan är det upp till kunden att utföra acceptanstest (se avsnitt 2.5) i syfte att verifiera att det
%som levererats är av tillräcklig kvalitet.

\chapter{Group organization} \label{sec:org}
Everyone should do everything, but some are more responsible than others.

\begin{itemize}
\item Project manager -- Coordination, time reporting, communication with regulatory body -- Weekly time reports, formal claims (based on failed acceptance test)
\item Development lead -- Design, implementation, source code quality -- jar_v0.5, jar_v0.9, jar_v1.0
\item Test manager -- Test strategy, unit testing, system testing -- Unit tests, Test spec v1.0 (incl. test code), test results
\item Requirements engineer -- End-user perspective, feature scoping, detailed requirements -- SRS v0.5, SRS v0.9, SRS v1.0
\item Sales engineer -- Marketing, customer communication, negotiations -- Marketing concept, signed contract (as supplier)
\item Domain expert -- Mastering Robocode, LU Rumble strategy, supplier communication, negotiations, acceptance testing -- Signed contract (as customer), acceptance test report, team jar-file
\end{itemize}

\chapter{Deliverables}
\begin{itemize}
\item Marketing concepts
\item SRS
\item Source code
\item Releases
\item Test code
\item Test spec
\item Test res
\item Acceptance test
\item LU Rumble team
\end{itemize}

\chapter{Course infrastructure}
\begin{itemize}
\item SRS template
\item Slack workspace
\item Contract templates
\begin{itemize}
\item Collaboration contract
\item Contract of sales
\end{itemize}
\item Time reporting
\item Robot team composition sheet
\end{itemize}

\end{document}
